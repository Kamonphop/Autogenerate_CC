edu.ncsu.csc326.coffeemaker.Recipe.<init>{
	entry ->   
	LS: public Recipe() [SubClass: aload_0]
	MC: public Recipe() calls java.lang.Object.<init>
	CF: public Recipe() -> this.name = ""
	LS: this.name = "" [SubClass: aload_0]
	CF: this.name = "" -> this.price = 0
	LS: this.price = 0 [SubClass: aload_0]
	CF: this.price = 0 -> this.amtCoffee = 0
	LS: this.amtCoffee = 0 [SubClass: aload_0]
	CF: this.amtCoffee = 0 -> this.amtMilk = 0
	LS: this.amtMilk = 0 [SubClass: aload_0]
	CF: this.amtMilk = 0 -> this.amtSugar = 0
	LS: this.amtSugar = 0 [SubClass: aload_0]
	CF: this.amtSugar = 0 -> this.amtChocolate = 0
	LS: this.amtChocolate = 0 [SubClass: aload_0]
	CF: this.amtChocolate = 0 -> 
	CF:  -> exit [Return Type: void]
}
edu.ncsu.csc326.coffeemaker.Recipe.getAmtChocolate{
	entry ->   
	LS: return amtChocolate [SubClass: aload_0]
	CF: return amtChocolate -> exit [Return Type: int]
}
edu.ncsu.csc326.coffeemaker.Recipe.setAmtChocolate{
	entry ->   
	LS: int amtChocolate = 0 [SubClass: istore_2]
	CF: int amtChocolate = 0 -> amtChocolate = Integer.parseInt(chocolate)
	LS: amtChocolate = Integer.parseInt(chocolate) [SubClass: aload_1]
	MC: amtChocolate = Integer.parseInt(chocolate) calls java.lang.Integer.parseInt
	LS: amtChocolate = Integer.parseInt(chocolate) [SubClass: istore_2]
	CF: amtChocolate = Integer.parseInt(chocolate) -> if (amtChocolate >= 0) [label = "goto"]
	LS: catch (NumberFormatException e) [SubClass: astore_3]
	CF: catch (NumberFormatException e) -> throw new RecipeException("Units of chocolate must be a positive integer")
	MC: throw new RecipeException("Units of chocolate must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Units of chocolate must be a positive integer") -> if (amtChocolate >= 0)
	LS: if (amtChocolate >= 0) [SubClass: iload_2]
	CF: if (amtChocolate >= 0) -> throw new RecipeException("Units of chocolate must be a positive integer") [label = "iflt"]
	CF: if (amtChocolate >= 0) -> this.amtChocolate = amtChocolate [label = "!iflt"]
	LS: this.amtChocolate = amtChocolate [SubClass: aload_0]
	LS: this.amtChocolate = amtChocolate [SubClass: iload_2]
	CF: this.amtChocolate = amtChocolate ->  [label = "goto"]
	MC: throw new RecipeException("Units of chocolate must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Units of chocolate must be a positive integer") -> 
	CF:  -> exit [Return Type: void]
}
edu.ncsu.csc326.coffeemaker.Recipe.getAmtCoffee{
	entry ->   
	LS: return amtCoffee [SubClass: aload_0]
	CF: return amtCoffee -> exit [Return Type: int]
}
edu.ncsu.csc326.coffeemaker.Recipe.setAmtCoffee{
	entry ->   
	LS: int amtCoffee = 0 [SubClass: istore_2]
	CF: int amtCoffee = 0 -> amtCoffee = Integer.parseInt(coffee)
	LS: amtCoffee = Integer.parseInt(coffee) [SubClass: aload_1]
	MC: amtCoffee = Integer.parseInt(coffee) calls java.lang.Integer.parseInt
	LS: amtCoffee = Integer.parseInt(coffee) [SubClass: istore_2]
	CF: amtCoffee = Integer.parseInt(coffee) -> if (amtCoffee >= 0) [label = "goto"]
	LS: catch (NumberFormatException e) [SubClass: astore_3]
	CF: catch (NumberFormatException e) -> throw new RecipeException("Units of coffee must be a positive integer")
	MC: throw new RecipeException("Units of coffee must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Units of coffee must be a positive integer") -> if (amtCoffee >= 0)
	LS: if (amtCoffee >= 0) [SubClass: iload_2]
	CF: if (amtCoffee >= 0) -> throw new RecipeException("Units of coffee must be a positive integer") [label = "iflt"]
	CF: if (amtCoffee >= 0) -> this.amtCoffee = amtCoffee [label = "!iflt"]
	LS: this.amtCoffee = amtCoffee [SubClass: aload_0]
	LS: this.amtCoffee = amtCoffee [SubClass: iload_2]
	CF: this.amtCoffee = amtCoffee ->  [label = "goto"]
	MC: throw new RecipeException("Units of coffee must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Units of coffee must be a positive integer") -> 
	CF:  -> exit [Return Type: void]
}
edu.ncsu.csc326.coffeemaker.Recipe.getAmtMilk{
	entry ->   
	LS: return amtMilk [SubClass: aload_0]
	CF: return amtMilk -> exit [Return Type: int]
}
edu.ncsu.csc326.coffeemaker.Recipe.setAmtMilk{
	entry ->   
	LS: int amtMilk = 0 [SubClass: istore_2]
	CF: int amtMilk = 0 -> amtMilk = Integer.parseInt(milk)
	LS: amtMilk = Integer.parseInt(milk) [SubClass: aload_1]
	MC: amtMilk = Integer.parseInt(milk) calls java.lang.Integer.parseInt
	LS: amtMilk = Integer.parseInt(milk) [SubClass: istore_2]
	CF: amtMilk = Integer.parseInt(milk) -> if (amtMilk >= 0) [label = "goto"]
	LS: catch (NumberFormatException e) [SubClass: astore_3]
	CF: catch (NumberFormatException e) -> throw new RecipeException("Units of milk must be a positive integer")
	MC: throw new RecipeException("Units of milk must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Units of milk must be a positive integer") -> if (amtMilk >= 0)
	LS: if (amtMilk >= 0) [SubClass: iload_2]
	CF: if (amtMilk >= 0) -> throw new RecipeException("Units of milk must be a positive integer") [label = "iflt"]
	CF: if (amtMilk >= 0) -> this.amtMilk = amtMilk [label = "!iflt"]
	LS: this.amtMilk = amtMilk [SubClass: aload_0]
	LS: this.amtMilk = amtMilk [SubClass: iload_2]
	CF: this.amtMilk = amtMilk ->  [label = "goto"]
	MC: throw new RecipeException("Units of milk must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Units of milk must be a positive integer") -> 
	CF:  -> exit [Return Type: void]
}
edu.ncsu.csc326.coffeemaker.Recipe.getAmtSugar{
	entry ->   
	LS: return amtSugar [SubClass: aload_0]
	CF: return amtSugar -> exit [Return Type: int]
}
edu.ncsu.csc326.coffeemaker.Recipe.setAmtSugar{
	entry ->   
	LS: int amtSugar = 0 [SubClass: istore_2]
	CF: int amtSugar = 0 -> amtSugar = Integer.parseInt(sugar)
	LS: amtSugar = Integer.parseInt(sugar) [SubClass: aload_1]
	MC: amtSugar = Integer.parseInt(sugar) calls java.lang.Integer.parseInt
	LS: amtSugar = Integer.parseInt(sugar) [SubClass: istore_2]
	CF: amtSugar = Integer.parseInt(sugar) -> if (amtSugar >= 0) [label = "goto"]
	LS: catch (NumberFormatException e) [SubClass: astore_3]
	CF: catch (NumberFormatException e) -> throw new RecipeException("Units of sugar must be a positive integer")
	MC: throw new RecipeException("Units of sugar must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Units of sugar must be a positive integer") -> if (amtSugar >= 0)
	LS: if (amtSugar >= 0) [SubClass: iload_2]
	CF: if (amtSugar >= 0) -> throw new RecipeException("Units of sugar must be a positive integer") [label = "iflt"]
	CF: if (amtSugar >= 0) -> this.amtSugar = amtSugar [label = "!iflt"]
	LS: this.amtSugar = amtSugar [SubClass: aload_0]
	LS: this.amtSugar = amtSugar [SubClass: iload_2]
	CF: this.amtSugar = amtSugar ->  [label = "goto"]
	MC: throw new RecipeException("Units of sugar must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Units of sugar must be a positive integer") -> 
	CF:  -> exit [Return Type: void]
}
edu.ncsu.csc326.coffeemaker.Recipe.getName{
	entry ->   
	LS: return name [SubClass: aload_0]
	CF: return name -> exit [Return Type: java.lang.Object]
}
edu.ncsu.csc326.coffeemaker.Recipe.setName{
	entry ->   
	LS: if(name != null) [SubClass: aload_1]
	CF: if(name != null) ->  [label = "ifnull"]
	CF: if(name != null) -> this.name = name [label = "!ifnull"]
	LS: this.name = name [SubClass: aload_0]
	LS: this.name = name [SubClass: aload_1]
	CF: this.name = name -> 
	CF:  -> exit [Return Type: void]
}
edu.ncsu.csc326.coffeemaker.Recipe.getPrice{
	entry ->   
	LS: return price [SubClass: aload_0]
	CF: return price -> exit [Return Type: int]
}
edu.ncsu.csc326.coffeemaker.Recipe.setPrice{
	entry ->   
	LS: int amtPrice = 0 [SubClass: istore_2]
	CF: int amtPrice = 0 -> amtPrice = Integer.parseInt(price)
	LS: amtPrice = Integer.parseInt(price) [SubClass: aload_1]
	MC: amtPrice = Integer.parseInt(price) calls java.lang.Integer.parseInt
	LS: amtPrice = Integer.parseInt(price) [SubClass: istore_2]
	CF: amtPrice = Integer.parseInt(price) -> if (amtPrice >= 0) [label = "goto"]
	LS: catch (NumberFormatException e) [SubClass: astore_3]
	CF: catch (NumberFormatException e) -> throw new RecipeException("Price must be a positive integer")
	MC: throw new RecipeException("Price must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Price must be a positive integer") -> if (amtPrice >= 0)
	LS: if (amtPrice >= 0) [SubClass: iload_2]
	CF: if (amtPrice >= 0) -> throw new RecipeException("Price must be a positive integer") [label = "iflt"]
	CF: if (amtPrice >= 0) -> this.price = amtPrice [label = "!iflt"]
	LS: this.price = amtPrice [SubClass: aload_0]
	LS: this.price = amtPrice [SubClass: iload_2]
	CF: this.price = amtPrice ->  [label = "goto"]
	MC: throw new RecipeException("Price must be a positive integer") calls edu.ncsu.csc326.coffeemaker.exceptions.RecipeException.<init>
	CF: throw new RecipeException("Price must be a positive integer") -> 
	CF:  -> exit [Return Type: void]
}
edu.ncsu.csc326.coffeemaker.Recipe.toString{
	entry ->   
	LS: return name [SubClass: aload_0]
	CF: return name -> exit [Return Type: java.lang.Object]
}
edu.ncsu.csc326.coffeemaker.Recipe.hashCode{
	entry ->   
	LS: final int prime = 31 [SubClass: istore_1]
	CF: final int prime = 31 -> int result = 1
	LS: int result = 1 [SubClass: istore_2]
	CF: int result = 1 -> result = prime * result + ((name == null) ? 0 : name.hashCode())
	LS: result = prime * result + ((name == null) ? 0 : name.hashCode()) [SubClass: iload_2]
	AI: result = prime * result + ((name == null) ? 0 : name.hashCode()) [SubClass: imul	Type: int]
	LS: result = prime * result + ((name == null) ? 0 : name.hashCode()) [SubClass: aload_0]
	CF: result = prime * result + ((name == null) ? 0 : name.hashCode()) -> result = prime * result + ((name == null) ? 0 : name.hashCode()) [label = "ifnonnull"]
	CF: result = prime * result + ((name == null) ? 0 : name.hashCode()) -> result = prime * result + ((name == null) ? 0 : name.hashCode()) [label = "!ifnonnull"]
	CF: result = prime * result + ((name == null) ? 0 : name.hashCode()) -> result = prime * result + ((name == null) ? 0 : name.hashCode()) [label = "goto"]
	LS: result = prime * result + ((name == null) ? 0 : name.hashCode()) [SubClass: aload_0]
	MC: result = prime * result + ((name == null) ? 0 : name.hashCode()) calls java.lang.String.hashCode
	AI: result = prime * result + ((name == null) ? 0 : name.hashCode()) [SubClass: iadd	Type: int]
	LS: result = prime * result + ((name == null) ? 0 : name.hashCode()) [SubClass: istore_2]
	CF: result = prime * result + ((name == null) ? 0 : name.hashCode()) -> return result
	LS: return result [SubClass: iload_2]
	CF: return result -> exit [Return Type: int]
}
edu.ncsu.csc326.coffeemaker.Recipe.equals{
	entry ->   
	LS: if (this == obj) [SubClass: aload_0]
	LS: if (this == obj) [SubClass: aload_1]
	CF: if (this == obj) -> if (obj == null) [label = "if_acmpne"]
	CF: if (this == obj) -> return true [label = "!if_acmpne"]
	CF: return true -> exit [Return Type: int]
	LS: if (obj == null) [SubClass: aload_1]
	CF: if (obj == null) -> if (getClass() != obj.getClass()) [label = "ifnonnull"]
	CF: if (obj == null) -> return false [label = "!ifnonnull"]
	CF: return false -> exit [Return Type: int]
	LS: if (getClass() != obj.getClass()) [SubClass: aload_0]
	MC: if (getClass() != obj.getClass()) calls java.lang.Object.getClass
	LS: if (getClass() != obj.getClass()) [SubClass: aload_1]
	MC: if (getClass() != obj.getClass()) calls java.lang.Object.getClass
	CF: if (getClass() != obj.getClass()) -> final Recipe other = (Recipe) obj [label = "if_acmpeq"]
	CF: if (getClass() != obj.getClass()) -> return false [label = "!if_acmpeq"]
	CF: return false -> exit [Return Type: int]
	LS: final Recipe other = (Recipe) obj [SubClass: aload_1]
	LS: final Recipe other = (Recipe) obj [SubClass: astore_2]
	CF: final Recipe other = (Recipe) obj -> if (name == null)
	LS: if (name == null) [SubClass: aload_0]
	CF: if (name == null) -> else if (!name.equals(other.name)) [label = "ifnonnull"]
	CF: if (name == null) -> if (other.name != null) [label = "!ifnonnull"]
	LS: if (other.name != null) [SubClass: aload_2]
	CF: if (other.name != null) -> return true [label = "ifnull"]
	CF: if (other.name != null) -> return false [label = "!ifnull"]
	CF: return false -> exit [Return Type: int]
	LS: else if (!name.equals(other.name)) [SubClass: aload_0]
	LS: else if (!name.equals(other.name)) [SubClass: aload_2]
	MC: else if (!name.equals(other.name)) calls java.lang.String.equals
	CF: else if (!name.equals(other.name)) -> return true [label = "ifne"]
	CF: else if (!name.equals(other.name)) -> return false [label = "!ifne"]
	CF: return false -> exit [Return Type: int]
	CF: return true -> exit [Return Type: int]
}
